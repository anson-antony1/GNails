// G Nail Growth - Prisma Schema
// Nail salon retention system with customer tracking, feedback, and winback campaigns

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Customer model - main customer entity
model Customer {
  id              String            @id @default(cuid())
  name            String?
  phone           String            @unique // main identifier
  email           String?           @unique
  marketingOptIn  Boolean           @default(true)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  // Relations
  visits          Visit[]
  winbackMessages WinbackMessage[]
  issues          Issue[]
  
  @@map("customers")
}

// Service model - treatments/services offered
model Service {
  id              String   @id @default(cuid())
  name            String   // e.g. "Spa Pedicure", "Gel-X Full Set"
  category        String   // "manicure", "pedicure", "brows", etc.
  basePrice       Int      // in cents or whole dollars
  durationMinutes Int
  isActive        Boolean  @default(true)
  
  // Relations
  visits          Visit[]
  
  @@map("services")
}

// Visit model - customer appointments/visits
model Visit {
  id              String    @id @default(cuid())
  customerId      String
  serviceId       String
  staffName       String?   // simple staff tracking for v1
  appointmentTime DateTime  // when they were scheduled or seated
  checkoutTime    DateTime? // nullable, may still be in progress
  priceCharged    Int       // final price charged
  source          String    // "walk-in", "online", etc.
  notes           String?   @db.Text
  
  // Relations
  customer        Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade)
  service         Service           @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  feedbackRequest FeedbackRequest?
  
  @@index([customerId])
  @@index([serviceId])
  @@index([appointmentTime])
  @@map("visits")
}

// FeedbackRequest model - post-visit feedback and reviews
model FeedbackRequest {
  id                 String    @id @default(cuid())
  visitId            String    @unique
  channel            String    // "sms" or "email"
  sentAt             DateTime?
  status             String    // "pending", "sent", "failed"
  rating             Int?      // 1-10 scale
  comment            String?   @db.Text
  respondedAt        DateTime?
  reviewLinkClicked  Boolean   @default(false)
  
  // Relations
  visit              Visit     @relation(fields: [visitId], references: [id], onDelete: Cascade)
  issue              Issue?
  
  @@index([visitId])
  @@index([status])
  @@map("feedback_requests")
}

// WinbackCampaign model - campaigns to bring back inactive customers
model WinbackCampaign {
  id                     String           @id @default(cuid())
  name                   String
  minDaysSinceLastVisit  Int              // e.g. 30
  maxDaysSinceLastVisit  Int              // e.g. 60
  messageTemplate        String           @db.Text // may contain {{firstName}} {{bookingLink}} etc.
  active                 Boolean          @default(true)
  
  // Relations
  messages               WinbackMessage[]
  
  @@map("winback_campaigns")
}

// WinbackMessage model - individual messages sent as part of campaigns
model WinbackMessage {
  id           String            @id @default(cuid())
  campaignId   String
  customerId   String
  sentAt       DateTime?
  status       String            // "pending", "sent", "failed"
  responseType String?           // "booked", "ignored", "opted_out"
  
  // Relations
  campaign     WinbackCampaign   @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  customer     Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  @@index([campaignId])
  @@index([customerId])
  @@index([status])
  @@map("winback_messages")
}

// Setting model - simple key-value configuration storage
model Setting {
  key   String @id
  value Json
  
  @@map("settings")
}

// Issue model - internal problem tracking from customer feedback
model Issue {
  id                 String           @id @default(cuid())
  customerId         String
  feedbackRequestId  String           @unique
  createdAt          DateTime         @default(now())
  status             String           @default("open") // "open", "in_progress", "resolved"
  severity           String?          // "low", "medium", "high"
  category           String?          // "rushed service", "cleanliness", "pricing", "wait time", etc.
  summary            String?          // AI-generated short summary
  details            String?          @db.Text // full text from customer comment
  ownerResponse      String?          @db.Text // pre-drafted response for owner to use
  resolvedAt         DateTime?
  resolvedBy         String?          // staff member who resolved it
  
  // Relations
  customer           Customer         @relation(fields: [customerId], references: [id], onDelete: Cascade)
  feedbackRequest    FeedbackRequest  @relation(fields: [feedbackRequestId], references: [id], onDelete: Cascade)
  
  @@index([customerId])
  @@index([status])
  @@index([severity])
  @@index([category])
  @@index([createdAt])
  @@map("issues")
}
